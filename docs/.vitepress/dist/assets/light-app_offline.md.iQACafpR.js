import{_ as e,c as a,o as i,a5 as o,bc as s}from"./chunks/framework.D4ctqEPk.js";const m=JSON.parse('{"title":"离线应用","description":"","frontmatter":{},"headers":[],"relativePath":"light-app/offline.md","filePath":"light-app/offline.md"}'),t={name:"light-app/offline.md"},l=o('<h1 id="离线应用" tabindex="-1">离线应用 <a class="header-anchor" href="#离线应用" aria-label="Permalink to &quot;离线应用&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">阅读本文，你将了解：</p><ul><li>如何处理前端静态资源包；</li><li>如何设置离线应用的访问地址；</li><li>如何控制版本更新。</li></ul></div><p>离线应用，就是把前端静态资源文件放置到客户端本地，提高访问速度的同时，也节省流量。当前离线应用功能只在移动客户端上提供。</p><h2 id="压缩包规范" tabindex="-1">压缩包规范 <a class="header-anchor" href="#压缩包规范" aria-label="Permalink to &quot;压缩包规范&quot;">​</a></h2><p>发布离线应用，需要对前端资源包进行压缩，格式规定为<code>zip</code>。除了格式要求，资源的目录也同样有要求，以下面例子为例：</p><p><img src="'+s+'" alt="离线资源"></p><p>正确的做法是，选中<code>mobile</code>文件夹进行压缩，而不是全选 mobile 内所有文件进行压缩。压缩包生成后，上传即可。</p><div class="tip custom-block"><p class="custom-block-title">离线包外部备用地址</p><p>除了在平台上传资源包外，还可以设置<code>离线包外部备用地址</code>，地址为一个在线可访问的资源地址，压缩包的规范需要保持一致。当设置了离线包外部备用地址时，客户端会优先使用该地址下载离线资源。</p><p>为了提高资源包的下载速度，可以配合 CDN 来设置该备用地址。</p></div><h2 id="启动地址" tabindex="-1">启动地址 <a class="header-anchor" href="#启动地址" aria-label="Permalink to &quot;启动地址&quot;">​</a></h2><p>压缩包上传成功后，还需要设置应用的启动地址。</p><p>当应用上架后被首次打开，客户端会根据应用的设置，把离线资源包下载到本地，并进行解压。所以离线应用在首次打开都会比较慢，因为多了一个下载及解压资源的过程。为了能在解压后，找到对应的应用，客户端制定了一套 URL 规范，根据上一步生成的压缩包，启动地址应该是这样填写：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//mobile/index.html</span></span></code></pre></div><p>URL 解析说明：</p><ul><li><code>local://</code> 特定协议，客户端会以离线应用的方式处理；</li><li><code>mobile</code> 压缩包解压后的一级目录，如果是多层级的，都可以拼上去；</li><li><code>index.html</code> 应用的入口文件。</li></ul><h2 id="前端-api-地址" tabindex="-1">前端 API 地址 <a class="header-anchor" href="#前端-api-地址" aria-label="Permalink to &quot;前端 API 地址&quot;">​</a></h2><p>因为离线应用是以<code>file://</code>协议打开，如下:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">file</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//offline-app/app_id/version/mobile/index.html</span></span></code></pre></div><p>所以，在离线应用中，Ajax 请求的 api 地址，切勿使用相对路径，请使用<strong>全路径</strong>。</p><h2 id="ios-wkwebview-的问题" tabindex="-1">iOS WKWebView 的问题 <a class="header-anchor" href="#ios-wkwebview-的问题" aria-label="Permalink to &quot;iOS WKWebView 的问题&quot;">​</a></h2><p>基于<code>WKWebView</code>的安全机制，离线应用以<code>file://</code>协议访问资源，而<code>Ajax请求</code>是走<code>http</code>的，这种情况下，会被认定为跨域。解决跨域的方式有很多，例如后台做<code>CORS</code>处理。</p><p>但是这里还存在一个问题，就是<code>cookie</code>。因为 cookie 本身也是有同源的限制，所以在跨域的情况下，cookie 无法被正常传递。所以，我们推荐使用其他的方式进行用户身份认证，例如使用<code>jwt(json web token)</code>。</p><h2 id="更新机制" tabindex="-1">更新机制 <a class="header-anchor" href="#更新机制" aria-label="Permalink to &quot;更新机制&quot;">​</a></h2><p>离线应用的更新，就不会像以<code>http</code>打开的应用方便。</p><p>如果需要更新离线应用，需要在管理后台上架新的应用版本，然后上传新的离线资源包。当应用上架后，在客户端首次打开，客户端会检测到应用有更新，就会再次下载并解压离线资源包，完成后，应用将正常打开。</p><blockquote><p>上架新版本后，可以在客户端切换底部 tab 来触发同步更新。</p></blockquote>',25),c=[l];function p(d,n,h,r,k,b){return i(),a("div",null,c)}const _=e(t,[["render",p]]);export{m as __pageData,_ as default};
